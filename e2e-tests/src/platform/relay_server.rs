// e2e-tests/src/relay_server_process.rs
//
// Real relay-server process management for E2E testing.
//
// This module provides a helper to start the actual relay-server binary
// with test configuration, ensuring true end-to-end testing that validates
// the complete startup sequence including config loading, port resolution,
// TLS certificate generation, and database initialization.
//
// DESIGN PRINCIPLE: Unlike the old TestServer which assembled internal
// components directly, this approach starts the actual binary, ensuring
// tests validate real-world behavior.
//
// ISOLATION: Each test instance runs in its own temporary directory with
// unique config.toml, runtime.toml, and database files. This enables
// parallel test execution without resource conflicts.

use anyhow::{Context, Result};
use std::io::{BufRead, BufReader};
use std::path::PathBuf;
use std::process::{Child, Command, Stdio};
use std::sync::atomic::{AtomicBool, Ordering};
use std::sync::Arc;
use std::time::{Duration, Instant};
use tempfile::TempDir;

/// Runtime configuration for dynamically assigned ports
/// Mirrors relay-server/src/config.rs RuntimeConfig structure
#[derive(Debug, Clone, serde::Deserialize)]
struct RuntimeConfig {
    server: RuntimeServerConfig,
    zeromq: RuntimeZeromqConfig,
}

#[derive(Debug, Clone, serde::Deserialize)]
struct RuntimeServerConfig {
    http_port: u16,
    #[allow(dead_code)]
    generated_at: String,
}

#[derive(Debug, Clone, serde::Deserialize)]
struct RuntimeZeromqConfig {
    receiver_port: u16,
    sender_port: u16,
    #[allow(dead_code)]
    generated_at: String,
}

/// Real relay-server process for E2E testing
///
/// Starts the actual relay-server binary with CONFIG_ENV=test,
/// waits for it to become ready, and provides port information
/// for EA simulators to connect.
///
/// Each instance runs in an isolated temporary directory with its own:
/// - config.test.toml (copied from relay-server/)
/// - runtime.toml (generated by server)
/// - e2e_test.db (SQLite database)
/// - certs/ (TLS certificates)
pub struct RelayServerProcess {
    child: Option<Child>,
    pub http_port: u16,
    pub zmq_pull_port: u16,
    pub zmq_pub_port: u16,
    /// Temporary directory for this test instance (auto-cleaned on drop)
    _temp_dir: TempDir,
    /// Path to the temp directory for reference
    working_dir: PathBuf,
    shutdown_flag: Arc<AtomicBool>,
    db_path: PathBuf,
}

impl RelayServerProcess {
    /// Start a new relay-server process with test configuration
    ///
    /// Creates an isolated temporary directory with all necessary files,
    /// then starts the relay-server binary within that directory.
    ///
    /// # Returns
    /// A RelayServer instance with dynamically assigned ports
    ///
    /// # Errors
    /// Returns an error if:
    /// - The temporary directory cannot be created
    /// - Required files cannot be copied
    /// - The server binary cannot be started
    /// - The server fails to become ready within timeout
    /// - Port information cannot be read from runtime.toml
    pub fn start() -> Result<Self> {
        Self::start_with_timeout(Duration::from_secs(30))
    }

    /// Start a new relay-server process with custom timeout
    pub fn start_with_timeout(timeout: Duration) -> Result<Self> {
        // Create unique temporary directory for this test instance
        let temp_dir = TempDir::new().context("Failed to create temporary directory")?;
        let working_dir = temp_dir.path().to_path_buf();

        // Find source relay-server directory for config files
        let relay_server_dir = Self::find_relay_server_dir()?;

        // Find workspace root directory (parent of relay-server)
        let workspace_root = relay_server_dir
            .parent()
            .context("Could not find workspace root")?
            .to_path_buf();

        // Copy config.toml (base config - required) to temp directory
        let src_base_config = relay_server_dir.join("config.toml");
        let dst_base_config = working_dir.join("config.toml");
        std::fs::copy(&src_base_config, &dst_base_config).with_context(|| {
            format!(
                "Failed to copy config.toml from {:?} to {:?}",
                src_base_config, dst_base_config
            )
        })?;

        // Copy config.test.toml to temp directory
        let src_config = relay_server_dir.join("config.test.toml");
        let dst_config = working_dir.join("config.test.toml");
        std::fs::copy(&src_config, &dst_config).with_context(|| {
            format!(
                "Failed to copy config.test.toml from {:?} to {:?}",
                src_config, dst_config
            )
        })?;

        // Copy certs directory if it exists (for TLS)
        let src_certs = relay_server_dir.join("certs");
        if src_certs.exists() {
            let dst_certs = working_dir.join("certs");
            Self::copy_dir_recursive(&src_certs, &dst_certs)
                .context("Failed to copy certs directory")?;
        }

        let runtime_toml_path = working_dir.join("runtime.toml");
        let db_path = working_dir.join("e2e_test.db");
        let database_url = format!(
            "sqlite://{}?mode=rwc",
            db_path.to_str().unwrap().replace('\\', "/")
        );

        // Build the binary first (from workspace root) if not already built
        // This ensures we don't wait for compilation during server startup
        let binary_path = workspace_root
            .join("target")
            .join("release")
            .join(if cfg!(windows) {
                "sankey-copier-server.exe"
            } else {
                "sankey-copier-server"
            });

        if !binary_path.exists() {
            eprintln!("Building relay-server binary (first time only)...");
            let build_status = Command::new("cargo")
                .args(["build", "--release", "-p", "sankey-copier-relay-server"])
                .current_dir(&workspace_root)
                .stdout(Stdio::inherit())
                .stderr(Stdio::inherit())
                .status()
                .context("Failed to build relay-server")?;

            if !build_status.success() {
                anyhow::bail!("Failed to build relay-server binary");
            }
        }

        // Start the relay-server binary directly
        // CONFIG_DIR points to the temp directory where config files were copied
        // DATABASE_URL overrides the config.toml database path
        let rust_log = std::env::var("RUST_LOG").unwrap_or_else(|_| "info".to_string());
        let mut child = Command::new(&binary_path)
            .env("CONFIG_DIR", working_dir.to_str().unwrap())
            .env("CONFIG_ENV", "test")
            .env("DATABASE_URL", &database_url)
            .env("RUST_LOG", rust_log)
            .stdout(Stdio::piped())
            .stderr(Stdio::piped())
            .spawn()
            .context("Failed to spawn relay-server process")?;

        let shutdown_flag = Arc::new(AtomicBool::new(false));

        // Spawn thread to read and log stderr
        let stderr = child.stderr.take();
        let shutdown_flag_clone_err = shutdown_flag.clone();
        let working_dir_for_log_err = working_dir.clone();
        if let Some(stderr) = stderr {
            std::thread::spawn(move || {
                let reader = BufReader::new(stderr);
                for line in reader.lines() {
                    if shutdown_flag_clone_err.load(Ordering::Relaxed) {
                        break;
                    }
                    if let Ok(line) = line {
                        eprintln!(
                            "[relay-server@{}] {}",
                            working_dir_for_log_err
                                .file_name()
                                .unwrap_or_default()
                                .to_string_lossy(),
                            line
                        );
                    }
                }
            });
        }

        // Spawn thread to read and log stdout
        let stdout = child.stdout.take();
        let shutdown_flag_clone_out = shutdown_flag.clone();
        let working_dir_for_log_out = working_dir.clone();
        if let Some(stdout) = stdout {
            std::thread::spawn(move || {
                let reader = BufReader::new(stdout);
                for line in reader.lines() {
                    if shutdown_flag_clone_out.load(Ordering::Relaxed) {
                        break;
                    }
                    if let Ok(line) = line {
                        eprintln!(
                            "[relay-server@{}] {}",
                            working_dir_for_log_out
                                .file_name()
                                .unwrap_or_default()
                                .to_string_lossy(),
                            line
                        );
                    }
                }
            });
        }

        // Wait for server to become ready by polling runtime.toml
        let start = Instant::now();
        let mut ports = None;

        while start.elapsed() < timeout {
            if runtime_toml_path.exists() {
                // Try to read and parse runtime.toml
                if let Ok(content) = std::fs::read_to_string(&runtime_toml_path) {
                    if let Ok(runtime) = toml::from_str::<RuntimeConfig>(&content) {
                        ports = Some((
                            runtime.server.http_port,
                            runtime.zeromq.receiver_port,
                            runtime.zeromq.sender_port,
                        ));
                        break;
                    }
                }
            }
            std::thread::sleep(Duration::from_millis(100));
        }

        let (http_port, zmq_pull_port, zmq_pub_port) = ports.with_context(|| {
            format!(
                "Timeout waiting for relay-server to start and create runtime.toml in {:?}",
                working_dir
            )
        })?;

        // Wait a bit more for HTTP server to be ready
        std::thread::sleep(Duration::from_millis(500));

        // GENERATE sankey_copier.ini
        // This simulates the Installer's job, providing the EA with ports and candidates.
        Self::generate_ea_ini(&working_dir, zmq_pull_port, zmq_pub_port)?;

        Ok(Self {
            child: Some(child),
            http_port,
            zmq_pull_port,
            zmq_pub_port,
            _temp_dir: temp_dir,
            working_dir,
            shutdown_flag,
            db_path,
        })
    }

    /// Generate sankey_copier.ini for EAs to read
    fn generate_ea_ini(working_dir: &std::path::Path, recv_port: u16, pub_port: u16) -> Result<()> {
        let ini_path = working_dir.join("sankey_copier.ini");

        // 1. Read config.toml to extract Candidates
        let config_path = working_dir.join("config.toml");
        let mut candidates = Vec::new();

        if config_path.exists() {
            match std::fs::read_to_string(&config_path) {
                Ok(content) => {
                    if let Ok(val) = toml::from_str::<toml::Value>(&content) {
                        if let Some(mapping) = val.get("symbol_mapping") {
                            if let Some(groups) = mapping.get("synonym_groups") {
                                if let Some(arr) = groups.as_array() {
                                    for group in arr {
                                        // Each group is array of strings
                                        if let Some(syms) = group.as_array() {
                                            for s in syms {
                                                if let Some(str_val) = s.as_str() {
                                                    candidates.push(str_val.to_string());
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                Err(e) => eprintln!("Failed to read config.toml for candidates: {}", e),
            }
        }

        // Remove duplicates and join
        candidates.sort();
        candidates.dedup();
        let candidates_str = candidates.join(",");

        let content = format!(
            "[ZeroMQ]\nReceiverPort={}\nPublisherPort={}\n\n[SymbolSearch]\nCandidates={}\n",
            recv_port, pub_port, candidates_str
        );

        std::fs::write(&ini_path, content).context("Failed to write sankey_copier.ini")?;
        Ok(())
    }

    /// Get path to the generated sankey_copier.ini
    pub fn ini_path(&self) -> PathBuf {
        self.working_dir.join("sankey_copier.ini")
    }

    /// Get the ZMQ PULL address (for EA to send messages)
    pub fn zmq_pull_address(&self) -> String {
        format!("tcp://127.0.0.1:{}", self.zmq_pull_port)
    }

    /// Get the ZMQ PUB address (for EA to receive messages)
    pub fn zmq_pub_address(&self) -> String {
        format!("tcp://127.0.0.1:{}", self.zmq_pub_port)
    }

    /// Get the HTTP API base URL
    #[allow(dead_code)]
    pub fn http_base_url(&self) -> String {
        format!("https://127.0.0.1:{}", self.http_port)
    }

    /// Get the working directory where relay-server is running
    #[allow(dead_code)]
    pub fn working_dir(&self) -> &PathBuf {
        &self.working_dir
    }

    /// Get the path to the test database file
    ///
    /// This can be used to connect to the database directly from tests
    /// to seed test data or verify state.
    pub fn db_path(&self) -> &PathBuf {
        &self.db_path
    }

    /// Get the SQLite connection URL for the test database
    ///
    /// Returns a URL suitable for sqlx connection
    pub fn db_url(&self) -> String {
        format!("sqlite://{}?mode=rwc", self.db_path.display())
    }

    /// Shutdown the server process
    pub fn shutdown(&mut self) {
        self.shutdown_flag.store(true, Ordering::Relaxed);

        if let Some(mut child) = self.child.take() {
            // Try graceful shutdown first (SIGTERM on Unix, TerminateProcess on Windows)
            let _ = child.kill();

            // Wait for process to exit
            let _ = child.wait();
        }

        // Note: temp_dir will be automatically cleaned up on drop
    }

    /// Find the relay-server directory (source for config files)
    fn find_relay_server_dir() -> Result<PathBuf> {
        // Try to find the workspace root by looking for Cargo.toml with [workspace]
        let mut current = std::env::current_dir()?;

        for _ in 0..10 {
            let cargo_toml = current.join("Cargo.toml");
            if cargo_toml.exists() {
                let content = std::fs::read_to_string(&cargo_toml)?;
                if content.contains("[workspace]") {
                    // Found workspace root, relay-server should be here
                    let relay_server_dir = current.join("relay-server");
                    if relay_server_dir.exists() {
                        return Ok(relay_server_dir);
                    }
                }
            }

            if let Some(parent) = current.parent() {
                current = parent.to_path_buf();
            } else {
                break;
            }
        }

        anyhow::bail!("Could not find relay-server directory")
    }

    /// Recursively copy a directory
    fn copy_dir_recursive(src: &PathBuf, dst: &PathBuf) -> Result<()> {
        std::fs::create_dir_all(dst)?;

        for entry in std::fs::read_dir(src)? {
            let entry = entry?;
            let src_path = entry.path();
            let dst_path = dst.join(entry.file_name());

            if src_path.is_dir() {
                Self::copy_dir_recursive(&src_path, &dst_path)?;
            } else {
                std::fs::copy(&src_path, &dst_path)?;
            }
        }

        Ok(())
    }
}

impl Drop for RelayServerProcess {
    fn drop(&mut self) {
        self.shutdown();
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_relay_server_starts_in_temp_dir() {
        let server = RelayServerProcess::start().expect("Failed to start relay-server");

        println!("Relay server started in temp directory:");
        println!("  Working dir: {:?}", server.working_dir());
        println!("  DB path: {:?}", server.db_path());
        println!("  ZMQ PULL: {}", server.zmq_pull_address());
        println!("  ZMQ PUB:  {}", server.zmq_pub_address());

        assert!(server.zmq_pull_port > 0);
        assert!(server.zmq_pub_port > 0);
        assert!(server.working_dir.exists());

        // Verify temp directory has the expected files
        assert!(server.working_dir.join("config.test.toml").exists());
        assert!(server.working_dir.join("runtime.toml").exists());

        // Server will be shutdown on drop
    }

    #[test]
    fn test_multiple_servers_parallel() {
        // Start two servers simultaneously to verify isolation
        let server1 = RelayServerProcess::start().expect("Failed to start server 1");
        let server2 = RelayServerProcess::start().expect("Failed to start server 2");

        println!(
            "Server 1: PULL={}, PUB={}",
            server1.zmq_pull_port, server1.zmq_pub_port
        );
        println!(
            "Server 2: PULL={}, PUB={}",
            server2.zmq_pull_port, server2.zmq_pub_port
        );

        // Verify different ports
        assert_ne!(server1.zmq_pull_port, server2.zmq_pull_port);
        assert_ne!(server1.zmq_pub_port, server2.zmq_pub_port);

        // Verify different working directories
        assert_ne!(server1.working_dir, server2.working_dir);

        // Verify different DB paths
        assert_ne!(server1.db_path, server2.db_path);
    }
}
